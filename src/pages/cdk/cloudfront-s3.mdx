export const meta = {
  title: 'Deploy a static website with S3 and CloudFront',
};

import { MyLayoutTest } from './../../components/Layout/MyLayout';

## Use Cases

1. What uses cases?

- Delivery static content to global users (homepage, videos, audio, text, etc.)
- Prevent direct access to S3
- Security HTTP headers, Geo restriction

2. What is the best practice?

- Understand the cost model
- Understand cache expeire time
- Understand deployment time
- Understand S3 policy to grant access to CloudFront only
- Monitor, log, optimization

What termilogy? - [Origin](https://aws.amazon.com/blogs/networking-and-content-delivery/amazon-cloudfront-introduces-response-headers-policies/) - [HTTP header ](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/getting-started-secure-static-website-cloudformation-template.html) - [Distribution](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Introduction.html)

## Architecture

![cloudfront-secure-static-website-overview](https://user-images.githubusercontent.com/20411077/169628984-09b8f432-47fa-45f2-b2b7-a1bd7c6f533c.png)

## Deploy

- Step 1. Create a bucket in us-east-1 (blocked public access)
- Step 2. Upload static web to the bucket
- Step 3. Create a CloudFront distribution (plan a 403 error)
- Step 4. Test and fix 403 error

## Discussion

- Understand Lambda@Edge
- CloudFront x Origin connection error
- HTTP 403 Forbidden
  - Server understood the request but it refused authorization
  - From S3 - Access Denied and S3 request ID
  - From CloudFront - generated by CloudFront
  - Geo-restriction

## CDK Stack

1. Create s3 bucket to store static content

```tsx
const bucket = new aws_s3.Bucket(this, 'BucketHostStaticWeb', {
  bucketName: 'bucket-static-web',
  // not production recommended
  removalPolicy: RemovalPolicy.DESTROY,
  // not production recommended
  autoDeleteObjects: true,
  // block public read
  publicReadAccess: false,
  // block public access - production recommended
  blockPublicAccess: aws_s3.BlockPublicAccess.BLOCK_ALL,
});
```

2. Create CloudFront OAI (identity)

```tsx
const cloudfrontOAI = new aws_cloudfront.OriginAccessIdentity(
  this,
  'CloudFrontOAIIcaDemo',
  {
    comment: 'OAI for ICA demo',
  }
);
```

3. Bucket grant access to (only) CloudFront OAI

```tsx
bucket.addToResourcePolicy(
  new aws_iam.PolicyStatement({
    actions: ['s3:GetObject'],
    resources: [bucket.arnForObjects('*')],
    principals: [
      new aws_iam.CanonicalUserPrincipal(
        cloudfrontOAI.cloudFrontOriginAccessIdentityS3CanonicalUserId
      ),
    ],
  })
);
```

4. Create a CloudFront distribution - S3 origin - OAI permissions

```tsx
const distribution = new aws_cloudfront.Distribution(this, 'Distribution', {
  defaultBehavior: {
    origin: new aws_cloudfront_origins.S3Origin(bucket, {
      originAccessIdentity: cloudfrontOAI,
    }),
  },
  // https://cloudfront-domain.net works
  // no need https://cloudfront-domain.net/index.html
  defaultRootObject: 'index.html',
});
```

5. Deploy the web (upload static content)

```tsx
new aws_s3_deployment.BucketDeployment(this, 'DeployWebsite', {
  sources: [aws_s3_deployment.Source.asset('./lib/website-dist')],
  destinationBucket: bucket,
  distribution: distribution,
});
```

## Bonus

- Route 53 and a domain from another account
- Request an ACM certificate to prove you own the domain
- Configure the CloudFront distribution with the ACM cert and custom domain
- Go to the other account (Route 53) and create a record CNAME

export default ({ children }) => (
  <MyLayoutTest frontmatter={meta}>{children}</MyLayoutTest>
);

;
